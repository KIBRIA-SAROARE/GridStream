**EdgeFlow — Streaming Event-Triggered Point-on-Wave Measurements (FPGA prototype)**

**Project:** Implementation and FPGA emulation of the prototype described in the paper "Streaming Event-Triggered Point-on-Wave Measurements for Disturbance Monitoring and Analysis" (IEEE) — link: https://ieeexplore.ieee.org/document/11205344

**Short description:**
- **Goal:** Reproduce the Simulink prototype from the paper, extend it to support FPGA-friendly implementations and evaluate area/power trade-offs for different data types and operator transformations.
- **Scope:** MATLAB/Simulink prototype, C++ code generation (synthesizable), FPGA synthesis/emulation (Vitis 22.1), and measurements/estimations of area and power across multiple commercial FPGA families.

**Key innovations (found during prototyping):**
- **Two-threshold event detection:** Instead of a single threshold, we use an upper and a lower threshold to correctly identify events and avoid missed or partial captures when triggering the relay.
- **Data-type exploration:** Tested multiple fixed-point and floating-point data formats to find the most area-efficient FPGA implementation for the algorithm.
- **Operator transformation for power efficiency:** Applied algebraic and operator-level transformations to reduce switching activity and power while preserving algorithmic accuracy.

**Motivation:**
- **Problem:** Inverter-based resources create dynamics that are difficult to analyze from traditional PMU streams alone. Important events (interruptions, frequency excursions, transients) can degrade power quality and impact critical infrastructure such as datacenters.
- **Why event-triggered P-O-W (Point-on-Wave):** Streaming event-triggered P-O-W data reduces bandwidth while capturing high-fidelity waveforms needed for root-cause analysis. An FPGA-emulated prototype lets us evaluate feasibility for distributed grid monitoring.

**Background (what to know before reproducing):**
- **PMU basics:** phasor estimation, reporting rates, and typical PMU limitations.
- **PMU communication limits:** sampling vs reporting trade-offs and network bandwidth constraints.
- **Phasor estimation errors & metrics:** amplitude, phase, frequency errors and LSE (least-squares error) as a detector statistic.
- **Event-triggered recording:** rationale, hysteresis-style detection with two thresholds, and streaming considerations.

**Repository layout (important files):**
- `DUT_Phasor_*` — generated C++/headers for the PMU/phasor processing block (Simulink generated). Contains `DUT_Phasor.cpp/.h`, `rtwtypes.h`, and helper code.
- `LSE_Metric_*` — generated C++/headers for the LSE (least-squares error) metric block and decision logic.
- `html/` directories — autogenerated Simulink report pages (viewable in a browser) showing model interfaces and subsystem diagrams.

**Design overview (main blocks):**
- **Phasor Measurement Unit (PMU):** estimates phasor amplitude, phase and frequency from sampled voltages/currents.
  - **NCO (Numerically Controlled Oscillator):** produces the reference phasor for mixing/rotation. Implementation notes:
    - Phase increment parameter (Δθ) is computed via accumulator size, nominal frequency and sampling rate. Example relation: Δθ = accumulator_size * (nominal_freq / sampling_freq) (Simulink symbol names: `del_theta`, `accumulator`, `phase_offset` — replace with model-specific names in the Simulink file).
    - Use fixed-point accumulator topology for FPGA friendliness.
  - **Filter:** low-pass anti-alias / reconstruction FIR with N = 256 taps (sinc-based design), cutoff ≈ 10 Hz, sampling rate 15360 Hz in the prototype.
  - **CORDIC:** used for phase shifting / rotation and computing cartesian/polar conversions with good hardware efficiency.
  - **Complex-to-real conversion:** rotation and addition/multiplication ops to extract real-valued measurements used by the LSE block.

- **LSE (Least Squares Error) block:**
  - Uses estimated phasor amplitude and frequency from the PMU and compares them with measured power waveform samples to compute an LSE error metric.
  - Our decision logic compares the LSE metric to two thresholds (upper & lower). The crossing of the upper threshold starts event capture; falling below the lower threshold ends capture (hysteresis). This prevents repeated partial captures caused by noisy oscillations.
  - A `Switch Enabled Subsystem` captures point-on-wave samples and forwards them to the communication stack for streaming.

**Why two thresholds:**
- A single threshold often fails to capture the full duration of a disturbance (it either misses the later parts or triggers too early/late). Two thresholds (upper/lower) form a hysteresis window that avoids chattering and ensures the whole event is captured. This change adds negligible area overhead in hardware.

**Datasets & experiments:**
- **Dataset used:** GESL 907 P-O-W datasets (transient phase-to-phase faults). Example dataset: 10 s recording, ~6.54 MB. (Replace with your local dataset path or a download URL.)
- **Experiment steps (high level):**
  1. Create and verify the Simulink prototype in MATLAB R2025b (Simulink version compatible with R2025b).
  2. Modify thresholds and data types to explore accuracy vs area/power trade-offs.
  3. Use Simulink Coder (Embedded Coder if available) to generate synthesizable C++ for `DUT_Phasor` and `LSE_Metric`.
  4. Synthesize and implement the C++ design in Vitis 22.1 (targeting multiple FPGA families) to estimate area and power.

**FPGA flow (recommended steps):**
- Prereqs: MATLAB R2025b (+ Simulink and Simulink Coder/Embedded Coder), Vitis 2022.1, supported Xilinx FPGA platforms and board files.
- High-level flow:
  - In MATLAB/Simulink: open the model (the Simulink model files are the source for `DUT_Phasor` and `LSE_Metric` auto-generated code). Run simulation to confirm behavior.
  - Generate C++ via Simulink Coder: select target language C++ and enable synthesize-friendly settings (fixed-point if targeting FPGA resources).
  - Import generated sources into Vitis HLS or Vitis platform project. Create an appropriate kernel for the PMU and LSE logic.
  - Run synthesis and implementation for target FPGA device(s). Collect area (LUT/FF/BRAM/DSP) and power estimates from the tool reports.

**Reproducible steps (example commands & notes):**
- MATLAB/Simulink: open and simulate the model manually. Example MATLAB commands (run inside MATLAB):
```
open_system('your_simulink_model_name');
sim('your_simulink_model_name');
% Modify threshold parameters programmatically if desired:
set_param('your_simulink_model_name/ThresholdBlock','UpperThreshold','0.5');
```
- Generate C++ (Simulink Coder): use the Simulink Coder GUI or `rtwbuild('modelname')` in MATLAB.

- Vitis (example outline):
  - Create a Vitis project and platform for your target board.
  - Add generated `DUT_Phasor.cpp` and `LSE_Metric.cpp` as kernels or IP.
  - Run synthesis and implementation via the Vitis GUI or CLI. (Refer to Vitis docs for exact CLI commands for your environment/platform.)

**Evaluation & measurements:**
- Measure phasor estimation error metrics (amplitude/phase/frequency RMSE) between Simulink ground-truth and the FPGA-emulated implementation.
- Report area (LUT/FF/BRAM/DSP) and power estimates for each data type/configuration.
- Include timing closure and achievable max frequency for the implemented kernels.

**Placeholders (figures & tables):**
- Figure 1: System block diagram (PMU + LSE + Trigger). [PLACEHOLDER FOR FIGURE]
- Figure 2: Timing diagram showing two-threshold hysteresis and event capture. [PLACEHOLDER FOR FIGURE]
- Table 1: Dataset summary (size, duration, sampling rate). [PLACEHOLDER FOR TABLE]
- Table 2: FPGA area/power summary across data types and FPGA parts. [PLACEHOLDER FOR TABLE]

**Files to inspect / edit:**
- `DUT_Phasor.cpp` / `DUT_Phasor.h` — phasor estimation implementation (generated). Edit thresholds and fixed-point scaling in the Simulink model and re-generate sources when needed.
- `LSE_Metric.cpp` / `LSE_Metric.h` — LSE computation and trigger logic.
- `html/` — autogenerated model documentation; useful to view interfaces and subsystem connections.

**Notes & tips:**
- Keep the data-type exploration controlled: change only one variable at a time (e.g., word length) and re-evaluate area/power/accuracy.
- Use the two-threshold hysteresis for reliable capture in noisy conditions.
- When moving to FPGA, prefer fixed-point implementations and use scaling analysis scripts (or Simulink Fixed-Point tools) to ensure dynamic range and saturation behavior are handled.

**Next steps / suggested experiments:**
- Sweep data types (e.g., float32, fixed Q1.15, Q2.14, etc.) and collect area/power/accuracy trade-off plots.
- Try small operator-level transformations (re-ordering multiplies/adds where associative) to measure power impact.
- Validate streaming stack: implement a basic packetization and send captured events to a PC/emulation host for post-processing.

**Contact / authorship:**
- Project maintained by the EdgeFlow team. For questions about reproducing specific steps, open an issue or contact the maintainers.

---

If you want, I can:
- Insert example figures/tables (I can produce plots from your experiment logs if provided).
- Add command-line Vitis scripts tailored to a specific target board (provide board/platform names).
- Add a minimal MATLAB script to automate threshold sweeps and C++ code generation.
# EdgeFlow

